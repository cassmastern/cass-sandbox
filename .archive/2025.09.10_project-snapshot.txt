./2025.09.08_project-snapshot.txt
./Dockerfile
./compilation.txt
./docs/_sec_sandbox/z_taxi.md
./docs/css/alphabet.css
./docs/css/cm-logo.css
./docs/css/color-vars.css
./docs/css/diagram-zoom.css
./docs/fonts/DancingScript-Bold.ttf
./docs/img/cass-interview.png
./docs/img/favicon.ico
./docs/img/ibm-toronto-olab.png
./docs/img/logo.svg
./docs/img/logo_theme-aware.svg
./docs/img/mermaid-beyond-reach.png
./docs/img/screenshot-mac-voiceover.png
./docs/index.md
./docs/js/alphabet-auto.js
./docs/js/diagram-zoom.js
./docs/js/mermaid.min.js
./docs/js/seamaiden.js
./docs/js/svg-patcher.js
./docs/sec_about/about-wf-breakdown.md
./docs/sec_about/about-sitedev.md
./docs/sec_about/feedback.md
./docs/sec_about/index.md
./docs/sec_about/roadmap.md
./docs/sec_about/whatsinhere.md
./docs/sec_accss/accss_.md
./docs/sec_accss/accss_diagram-dilemma.md
./docs/sec_accss/breakthru1-mermaid-svg.md
./docs/sec_accss/breakthru2-mermaid-accessible.md
./docs/sec_accss/index.md
./docs/sec_accss/visuals-for-the-sightless.md
./docs/sec_cheatsheets/cheatsheet-docker.md
./docs/sec_cheatsheets/cheatsheet-kubectl.md
./docs/sec_cheatsheets/cheatsheet_compound-modifiers.md
./docs/sec_cheatsheets/index.md
./docs/sec_cloud/aws-gcp-azure.md
./docs/sec_cloud/aws-gcp-azure_glossary.md
./docs/sec_cloud/aws-gcp-azure_glossary_old.md
./docs/sec_cloud/index.md
./docs/sec_cloud/jakarta-ee-azure.md
./docs/sec_freeform/ai-accessibility.md
./docs/sec_freeform/ai-accessibility_bus.md
./docs/sec_freeform/ibm-sanfran.md
./docs/sec_freeform/index.md
./docs/sec_gloss/gloss_cloud-native.md
./docs/sec_gloss/gloss_kuber.md
./docs/sec_gloss/gloss_networking.md
./docs/sec_gloss/gloss_oss.md
./docs/sec_gloss/index.md
./docs/sec_net-sec/index.md
./docs/sec_net-sec/network_data_center.md
./docs/sec_net-sec/network_data_center_mitre.md
./docs/sec_net-sec/network_data_center_stride.md
./mkdocs.yml
./readme.md
./requirements.txt

===== requirements.txt =====
# MkDocs core
mkdocs==1.6.1
mkdocs-material==9.5.39

# Plugins
mkdocs-mermaid2-plugin==1.2.1
mkdocs-awesome-pages-plugin==2.8.0

# Extensions
pymdown-extensions==10.8.1
mkdocs-material-extensions==1.3.1

# for graph view of site content
# re-add after CICD stabilizes: jinja2==3.1.3
===== Dockerfile =====
FROM python:3.11-slim

WORKDIR /app

# Set environment variables early (these rarely change)
ENV PIP_ROOT_USER_ACTION=ignore
ENV PIP_DISABLE_PIP_VERSION_CHECK=1
ENV MKDOCS_WATCHDOG_USE_POLLING=true

# Copy only requirements first for better caching
COPY requirements.txt /app/

# Install dependencies in a separate layer
# This layer will only rebuild if requirements.txt changes
RUN pip install --no-cache-dir -r requirements.txt

# Copy Mermaid JS explicitly for reproducibility
COPY docs/js/mermaid.min.js /app/docs/js/mermaid.min.js

# Copy the rest of the application files
# This layer will rebuild when docs/config changes, but deps stay cached
COPY . /app

EXPOSE 8000

CMD ["mkdocs", "serve", "-a", "0.0.0.0:8000"]
===== mkdocs.yml =====
site_name: "Cass's Sandobx"
site_url: https://cassmastern.github.io/cass-sandbox/
docs_dir: docs
copyright: "<a href='https://cassmastern.github.io/cass-sandbox/sec_about/feedback/'><span class='logo-text'>CM</span> 2025.</a>"
exclude:
  - archive/

theme:
  name: material
  logo: img/logo.svg
  favicon: img/favicon.ico
  features:
    - navigation.top
    - navigation.footer
    - navigation.indexes
    - search.highlight
    - search.suggest
    - search.share
    - content.code.copy
    - content.code.select
  palette:
    - scheme: slate
      toggle:
        icon: material/brightness-7
        name: Switch to light mode
    - scheme: default
      toggle:
        icon: material/brightness-4
        name: Switch to dark mode

plugins:
  - search
  - mermaid2:
      javascript: js/mermaid.min.js
  - awesome-pages

extra:
  generator: false
  analytics:
    provider: google
    property: G-GD2XWDMP2E
  consent:
    title: Cookie consent
    description: >
      We use cookies to recognize your repeated visits and preferences, as well
      as to measure the effectiveness of our documentation and whether users
      find what they're searching for. With your consent, you're helping us to
      make our documentation better.

markdown_extensions:
  - admonition
  - pymdownx.details
  - pymdownx.superfences:
      custom_fences:
        - name: mermaid
          class: mermaid
          format: !!python/name:mermaid2.fence_mermaid
  - toc:
      permalink: true

extra_javascript:
  - js/seamaiden.js
  - js/diagram-zoom.js
  - js/alphabet-auto.js
  - js/svg-patcher.js

extra_css:
  - css/alphabet.css
  - css/diagram-zoom.css
  - css/cm-logo.css
  - css/color-vars.css
  

===== .pa11yci.json =====
{
  "defaults": {
    "chromeLaunchConfig": {
      "args": [
        "--no-sandbox",
        "--disable-setuid-sandbox"
      ]
    }
  }
}

===== scripts referenced in mkdocs.yml =====

===== files under docs/js =====

===== docs/js/alphabet-auto.js =====
document.addEventListener("DOMContentLoaded", () => {
  // Run only on glossary pages
  if (!location.pathname.includes("gloss_")) return;

  const toc = document.querySelector(".md-sidebar--secondary nav");
  if (!toc) return;

  const table = document.querySelector(".md-typeset table");
  if (!table) return;

  const rows = table.querySelectorAll("tbody tr");
  if (!rows.length) return;

  const foundLetters = {};

  // Assign IDs to first cells based on first letter
  rows.forEach(row => {
    const firstCell = row.querySelector("td");
    if (!firstCell) return;
    const text = firstCell.textContent.trim();
    if (!text) return;
    const letter = text[0].toUpperCase();
    if (!/^[A-Z]$/.test(letter)) return;
    if (!foundLetters[letter]) {
      foundLetters[letter] = true;
      firstCell.id = `letter-${letter}`;
    }
  });

  // Build alphabet navigation
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  const ul = document.createElement("ul");
  ul.classList.add("alphabet-list");

  alphabet.forEach(letter => {
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.textContent = letter;

    if (foundLetters[letter]) {
      a.href = `#letter-${letter}`;
      a.addEventListener("click", e => {
        e.preventDefault();
        const target = document.getElementById(`letter-${letter}`);
        if (target) {
          target.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      });
    } else {
      a.style.opacity = "0.3";
      a.style.pointerEvents = "none";
    }

    li.appendChild(a);
    ul.appendChild(li);
  });

  // Replace native TOC with alphabet nav
  toc.innerHTML = "";
  const wrapper = document.createElement("div");
  wrapper.classList.add("alphabet-sticky");
  wrapper.appendChild(ul);
  toc.appendChild(wrapper);

  // Scroll spy: highlight current letter
  window.addEventListener("scroll", () => {
    let current = null;
    alphabet.forEach(letter => {
      const el = document.getElementById(`letter-${letter}`);
      if (el) {
        const rect = el.getBoundingClientRect();
        if (rect.top <= 100) current = letter;
      }
    });
    document.querySelectorAll(".alphabet-list a").forEach(a => {
      a.classList.toggle("active", a.textContent === current);
    });
  });
});


===== docs/js/diagram-zoom.js =====
/**
 * Fixed and simplified diagram zoom functionality
 * Addresses multiple SVG binding issues and race conditions
 * Updated to handle Mermaid theme reinitialization
 */
(function () {
  'use strict';

  // Global state
  let lightbox, content, escHandler, currentSvg;
  const boundSvgs = new WeakSet(); // Track bound SVGs to prevent double-binding

  // Configuration
  const CONFIG = {
    minScale: 0.25,
    maxScale: 4,
    zoomStep: 0.15,
    debugMode: false
  };

  const log = CONFIG.debugMode ? console.log.bind(console, '[zoom]') : () => {};

  /**
   * Create lightbox overlay (singleton pattern)
   */
  function ensureLightbox() {
    if (lightbox) return lightbox;
    
    lightbox = document.createElement("div");
    lightbox.className = "mz-lightbox";
    lightbox.setAttribute("role", "dialog");
    lightbox.setAttribute("aria-modal", "true");
    lightbox.setAttribute("aria-label", "Diagram zoom view");
    lightbox.setAttribute("aria-hidden", "true");
    lightbox.tabIndex = -1;

    content = document.createElement("div");
    content.className = "mz-lightbox__content";
    lightbox.appendChild(content);

    // Close on background click
    lightbox.addEventListener("click", (e) => {
      if (e.target === lightbox || e.target === content) {
        closeLightbox();
      }
    });

    // Prevent wheel events from bubbling to page
    lightbox.addEventListener("wheel", (e) => {
      e.stopPropagation();
    }, { passive: false });

    document.body.appendChild(lightbox);
    log('Lightbox created');
    
    return lightbox;
  }

  /**
   * Open lightbox with SVG
   */
  function openLightbox(originalSvg) {
    try {
      ensureLightbox();
      content.innerHTML = "";
      currentSvg = originalSvg;

      // Clone the SVG
      const clone = originalSvg.cloneNode(true);
      clone.classList.add("mz-lightbox__svg");
      
      // Get dimensions safely
      let width, height;
      try {
        const bbox = originalSvg.getBBox();
        width = bbox.width || originalSvg.clientWidth || 400;
        height = bbox.height || originalSvg.clientHeight || 300;
      } catch (e) {
        width = originalSvg.clientWidth || 400;
        height = originalSvg.clientHeight || 300;
      }
      
      // Set initial dimensions
      clone.style.width = width + "px";
      clone.style.height = height + "px";
      
      content.appendChild(clone);
      
      // Show lightbox
      lightbox.setAttribute("aria-hidden", "false");
      lightbox.focus();

      // Initialize zoom controls
      initializeZoomControls(clone);

      // Set up keyboard handler
      setupKeyboardHandler();

      log('Lightbox opened');

    } catch (error) {
      console.warn('Error opening lightbox:', error);
    }
  }

  /**
   * Initialize zoom and pan controls
   */
  function initializeZoomControls(svgClone) {
    let scale = 1;
    let currentX = 0;
    let currentY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    function updateTransform() {
      svgClone.style.transform = `translate(${currentX}px, ${currentY}px) scale(${scale})`;
    }

    // Mouse wheel zoom
    svgClone.addEventListener("wheel", (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const rect = svgClone.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      const mouseX = e.clientX - centerX;
      const mouseY = e.clientY - centerY;
      
      const delta = e.deltaY > 0 ? -CONFIG.zoomStep : CONFIG.zoomStep;
      const newScale = Math.min(Math.max(CONFIG.minScale, scale + delta), CONFIG.maxScale);
      
      if (newScale !== scale) {
        const scaleDiff = newScale - scale;
        currentX -= mouseX * scaleDiff;
        currentY -= mouseY * scaleDiff;
        scale = newScale;
        updateTransform();
      }
    }, { passive: false });

    // Mouse drag
    svgClone.addEventListener("mousedown", (e) => {
      e.preventDefault();
      isDragging = true;
      dragStartX = e.clientX - currentX;
      dragStartY = e.clientY - currentY;
      svgClone.style.cursor = "grabbing";
    });

    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      e.preventDefault();
      currentX = e.clientX - dragStartX;
      currentY = e.clientY - dragStartY;
      updateTransform();
    });

    document.addEventListener("mouseup", () => {
      if (!isDragging) return;
      isDragging = false;
      svgClone.style.cursor = "grab";
    });

    // Touch handling
    let initialTouchDistance = 0;
    let initialScale = 1;

    svgClone.addEventListener("touchstart", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        initialTouchDistance = Math.sqrt(dx * dx + dy * dy);
        initialScale = scale;
      }
    }, { passive: false });

    svgClone.addEventListener("touchmove", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (initialTouchDistance > 0) {
          const scaleChange = distance / initialTouchDistance;
          const newScale = Math.min(Math.max(CONFIG.minScale, initialScale * scaleChange), CONFIG.maxScale);
          scale = newScale;
          updateTransform();
        }
      }
    }, { passive: false });

    svgClone.addEventListener("touchend", (e) => {
      if (e.touches.length < 2) {
        initialTouchDistance = 0;
        initialScale = scale;
      }
    });

    // Double-click to reset
    svgClone.addEventListener("dblclick", (e) => {
      e.preventDefault();
      scale = 1;
      currentX = 0;
      currentY = 0;
      updateTransform();
    });
  }

  /**
   * Set up keyboard handler
   */
  function setupKeyboardHandler() {
    escHandler = (e) => {
      if (e.key === "Escape") {
        closeLightbox();
      }
    };
    
    document.addEventListener("keydown", escHandler);
  }

  /**
   * Close lightbox
   */
  function closeLightbox() {
    if (!lightbox) return;
    
    try {
      lightbox.setAttribute("aria-hidden", "true");
      
      if (content) {
        content.innerHTML = "";
      }
      
      if (escHandler) {
        document.removeEventListener("keydown", escHandler);
        escHandler = null;
      }
      
      currentSvg = null;
      log('Lightbox closed');
      
    } catch (error) {
      console.warn('Error closing lightbox:', error);
    }
  }

  /**
   * Bind zoom functionality to SVG elements
   * Fixed to prevent double-binding and race conditions
   */
  function bindZoomToSvgs() {
    const unboundSvgs = document.querySelectorAll('.mermaid svg');
    let boundCount = 0;
    
    unboundSvgs.forEach((svg) => {
      // Skip if already bound (using WeakSet for reliable tracking)
      if (boundSvgs.has(svg)) {
        return;
      }
      
      // Mark as bound immediately
      boundSvgs.add(svg);
      svg.classList.add('mz-zoomable');
      
      // Add click handler
      const clickHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        openLightbox(svg);
      };
      
      svg.addEventListener('click', clickHandler);
      
      boundCount++;
      log(`Bound zoom to SVG ${boundCount}`);
    });
    
    return boundCount;
  }

  /**
   * Clear WeakSet when Mermaid reinitializes
   * This is necessary because the old SVGs are removed from DOM
   */
  function clearBoundSvgs() {
    // WeakSet doesn't have a clear method, but since the old SVGs
    // are garbage collected when removed from DOM, we can create a new WeakSet
    // However, since we can't reassign the const, we'll rely on garbage collection
    log('Mermaid reinitialized - old SVG references will be garbage collected');
  }

  /**
   * Wait for Mermaid diagrams and bind zoom
   */
  function waitAndBindDiagrams() {
    const startTime = Date.now();
    const maxWait = 5000;
    
    function checkForSvgs() {
      const svgs = document.querySelectorAll('.mermaid svg');
      const unboundSvgs = Array.from(svgs).filter(svg => !boundSvgs.has(svg));
      const timeElapsed = Date.now() - startTime;
      
      if (unboundSvgs.length > 0) {
        const boundCount = bindZoomToSvgs();
        log(`Bound zoom to ${boundCount} new diagrams`);
        
        // Dispatch event
        document.dispatchEvent(new CustomEvent('diagramZoomBound', {
          detail: { count: boundCount }
        }));
      }
      
      // Continue checking if within time limit
      if (timeElapsed < maxWait) {
        setTimeout(checkForSvgs, 200);
      }
    }
    
    checkForSvgs();
  }

  /**
   * Handle Mermaid reinitialization (theme changes)
   */
  function handleMermaidReinit() {
    log('Mermaid reinitialized, rebinding zoom functionality...');
    clearBoundSvgs();
    
    // Wait a bit longer for Mermaid to fully render new SVGs
    setTimeout(() => {
      waitAndBindDiagrams();
    }, 200);
  }

  /**
   * Initialize zoom functionality
   */
  function initZoom() {
    log('Initializing diagram zoom...');
    
    // Ensure lightbox exists
    ensureLightbox();
    
    // Initial binding after a short delay for Mermaid rendering
    setTimeout(waitAndBindDiagrams, 300);
    
    // Listen for Mermaid reinitialization (theme changes)
    document.addEventListener('mermaidReinitialized', handleMermaidReinit);
    
    // Set up mutation observer for dynamic content
    const observer = new MutationObserver((mutations) => {
      let foundNewDiagrams = false;
      
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === 1) {
            if (node.classList?.contains('mermaid') || 
                node.querySelector?.('.mermaid') ||
                (node.tagName === 'SVG' && node.closest?.('.mermaid'))) {
              foundNewDiagrams = true;
            }
          }
        });
      });

      if (foundNewDiagrams) {
        log('New diagrams detected, binding zoom...');
        setTimeout(bindZoomToSvgs, 300);
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Listen for accessibility processing completion
    document.addEventListener('diagramsAccessibilityProcessed', () => {
      log('Accessibility processing completed, checking for new diagrams');
      setTimeout(bindZoomToSvgs, 100);
    });

    log('Zoom initialization complete');
  }

  /**
   * Cleanup function
   */
  function cleanup() {
    if (lightbox && lightbox.parentNode) {
      lightbox.parentNode.removeChild(lightbox);
    }
    lightbox = null;
    content = null;
    currentSvg = null;
    
    if (escHandler) {
      document.removeEventListener('keydown', escHandler);
      escHandler = null;
    }
    
    // Remove event listeners
    document.removeEventListener('mermaidReinitialized', handleMermaidReinit);
  }

  /**
   * Handle page visibility changes
   */
  function handleVisibilityChange() {
    if (document.hidden && lightbox && lightbox.getAttribute('aria-hidden') === 'false') {
      closeLightbox();
    }
  }

  /**
   * Main initialization
   */
  function initialize() {
    cleanup(); // Clean up any existing state
    setTimeout(initZoom, 200);
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }

  // Handle Material theme's instant navigation
  if (typeof document$ !== 'undefined' && document$.subscribe) {
    document$.subscribe(() => {
      setTimeout(initialize, 100);
    });
  } else {
    // Handle regular page loads
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initialize);
    } else {
      initialize();
    }
  }

  // Expose for debugging
  if (CONFIG.debugMode) {
    window.diagramZoom = {
      bindZoomToSvgs,
      openLightbox,
      closeLightbox,
      cleanup,
      handleMermaidReinit
    };
  }

  // Handle page unload
  window.addEventListener('beforeunload', cleanup);

})();


===== docs/js/mermaid.min.js =====
// TL;DT

===== docs/js/seamaiden.js =====
// docs/js/seamaiden-theme-switchr.js
let mermaidInitialized = false;

function initializeMermaid() {
  const isDarkMode = document.body.getAttribute('data-md-color-scheme') === 'slate';
  
  // Enhanced theme variables for better visibility
  const lightThemeVars = {
    // Base colors
    'primaryColor': '#ffffff',
    'primaryTextColor': '#000000',
    'primaryBorderColor': '#333333',
    'lineColor': '#333333',
    
    // Background colors
    'background': '#ffffff',
    'secondaryColor': '#f9f9f9',
    'tertiaryColor': '#f0f0f0',
    
    // Text colors
    'textColor': '#000000',
    'actorTextColor': '#000000',
    'labelTextColor': '#000000',
    
    // Sequence diagram specific
    'actorBkg': '#ffffff',
    'actorBorder': '#333333',
    'actorLineColor': '#333333',
    'signalColor': '#333333',
    'signalTextColor': '#000000',
    'activationBorderColor': '#333333',
    'activationBkgColor': '#f4f4f4',
    'sequenceNumberColor': '#ffffff',
    
    // Flowchart specific
    'nodeBkg': '#ffffff',
    'nodeBorder': '#333333',
    'clusterBkg': '#f9f9f9',
    'clusterBorder': '#333333',
    'defaultLinkColor': '#333333',
    'titleColor': '#000000',
    'edgeLabelBackground': '#ffffff',
    
    // Git diagram
    'git0': '#ff6b6b',
    'git1': '#4ecdc4',
    'git2': '#45b7d1',
    'git3': '#96ceb4',
    'git4': '#feca57',
    'git5': '#ff9ff3',
    'git6': '#54a0ff',
    'git7': '#5f27cd',
    
    // Font settings
    'fontFamily': 'sans-serif',
    'fontSize': '14px'
  };

  const darkThemeVars = {
    // Base colors
    'primaryColor': '#2d2d2d',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#aaaaaa',
    'lineColor': '#aaaaaa',
    
    // Background colors
    'background': '#1e1e1e',
    'secondaryColor': '#2d2d2d',
    'tertiaryColor': '#3d3d3d',
    
    // Text colors
    'textColor': '#ffffff',
    'actorTextColor': '#ffffff',
    'labelTextColor': '#ffffff',
    
    // Sequence diagram specific
    'actorBkg': '#2d2d2d',
    'actorBorder': '#aaaaaa',
    'actorLineColor': '#aaaaaa',
    'signalColor': '#aaaaaa',
    'signalTextColor': '#ffffff',
    'activationBorderColor': '#aaaaaa',
    'activationBkgColor': '#3d3d3d',
    'sequenceNumberColor': '#1e1e1e',
    
    // Flowchart specific
    'nodeBkg': '#2d2d2d',
    'nodeBorder': '#aaaaaa',
    'clusterBkg': '#1e1e1e',
    'clusterBorder': '#666666',
    'defaultLinkColor': '#aaaaaa',
    'titleColor': '#ffffff',
    'edgeLabelBackground': '#1e1e1e',
    
    // Git diagram
    'git0': '#ff6b6b',
    'git1': '#4ecdc4',
    'git2': '#45b7d1',
    'git3': '#96ceb4',
    'git4': '#feca57',
    'git5': '#ff9ff3',
    'git6': '#54a0ff',
    'git7': '#5f27cd',
    
    // Font settings
    'fontFamily': 'sans-serif',
    'fontSize': '14px'
  };

  const config = {
    startOnLoad: true,
    theme: isDarkMode ? 'dark' : 'default',
    themeVariables: isDarkMode ? darkThemeVars : lightThemeVars,
    flowchart: {
      useMaxWidth: true,
      htmlLabels: true,
      curve: 'cardinal'
    },
    sequence: {
      useMaxWidth: true,
      diagramMarginX: 50,
      diagramMarginY: 10,
      actorMargin: 50,
      width: 150,
      height: 65,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      mirrorActors: true,
      bottomMarginAdj: 1,
      useMaxWidth: true,
      rightAngles: false,
      showSequenceNumbers: false
    },
    gantt: {
      useMaxWidth: true
    },
    journey: {
      useMaxWidth: true
    },
    timeline: {
      useMaxWidth: true
    },
    gitGraph: {
      useMaxWidth: true
    },
    c4: {
      useMaxWidth: true
    },
    securityLevel: 'loose',
    fontFamily: 'sans-serif'
  };

  mermaid.initialize(config);
  mermaidInitialized = true;
}

function reinitializeMermaid() {
  // Clear any existing mermaid content
  document.querySelectorAll('.mermaid').forEach(element => {
    if (element.getAttribute('data-processed')) {
      element.removeAttribute('data-processed');
      element.innerHTML = element.getAttribute('data-original-content') || element.innerHTML;
    }
  });
  
  mermaidInitialized = false;
  initializeMermaid();
  
  // Re-render all diagrams
  mermaid.run().then(() => {
    // Process SVGs in the correct sequence after re-rendering
    processNewSvgs();
  }).catch(() => {
    // Fallback if mermaid.run() doesn't return a promise
    setTimeout(() => {
      processNewSvgs();
    }, 300);
  });
}

function processNewSvgs() {
  // Wait for SVGs to be fully rendered
  setTimeout(() => {
    // 1. First, apply accessibility patches
    patchSvgAccessibility();
    
    // 2. Then notify zoom script to rebind
    setTimeout(() => {
      document.dispatchEvent(new CustomEvent('mermaidReinitialized', {
        detail: { reason: 'themeChange' }
      }));
    }, 50);
  }, 100);
}

function patchSvgAccessibility() {
  // Apply the same accessibility fixes as svg-patcher.js
  document.querySelectorAll('svg[role="graphics-document document"]').forEach(svg => {
    svg.setAttribute('role', 'img');
    svg.setAttribute('tabindex', '0');
    svg.removeAttribute('aria-roledescription');
  });
  
  // Dispatch event to notify that accessibility processing is complete
  document.dispatchEvent(new CustomEvent('diagramsAccessibilityProcessed', {
    detail: { count: document.querySelectorAll('.mermaid svg[role="img"]').length }
  }));
}

// Initialize when DOM is ready
document$.subscribe(() => {
  if (!mermaidInitialized) {
    // Store original content before processing
    document.querySelectorAll('.mermaid').forEach(element => {
      if (!element.getAttribute('data-original-content')) {
        element.setAttribute('data-original-content', element.innerHTML);
      }
    });
    
    initializeMermaid();
  }
});

// Watch for theme changes
const themeObserver = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.attributeName === 'data-md-color-scheme') {
      setTimeout(() => {
        reinitializeMermaid();
      }, 100);
    }
  });
});

// Start observing theme changes
themeObserver.observe(document.body, { 
  attributes: true, 
  attributeFilter: ['data-md-color-scheme'] 
});

// Handle dynamic content loading (if needed)
if (typeof document$ !== 'undefined') {
  document$.subscribe(() => {
    setTimeout(() => {
      if (mermaidInitialized) {
        mermaid.run();
      }
    }, 100);
  });
}


===== docs/js/svg-patcher.js =====
// svg-patcher.js - Updated to work with theme switching
function patchSvgAccessibility() {
  document.querySelectorAll('svg[role="graphics-document document"]').forEach(svg => {
    svg.setAttribute('role', 'img');
    svg.setAttribute('tabindex', '0');
    svg.removeAttribute('aria-roledescription');
  });
}

// Initial patching on page load
window.addEventListener('load', function() {
  setTimeout(function() {
    patchSvgAccessibility();
    
    // Dispatch event to notify other scripts
    document.dispatchEvent(new CustomEvent('diagramsAccessibilityProcessed', {
      detail: { count: document.querySelectorAll('.mermaid svg[role="img"]').length }
    }));
  }, 1000); // Keep original delay for initial load
});

// Handle Material theme's instant navigation
if (typeof document$ !== 'undefined' && document$.subscribe) {
  document$.subscribe(() => {
    setTimeout(() => {
      patchSvgAccessibility();
      document.dispatchEvent(new CustomEvent('diagramsAccessibilityProcessed', {
        detail: { count: document.querySelectorAll('.mermaid svg[role="img"]').length }
      }));
    }, 1200); // Slightly longer delay for navigation
  });
}


===== files under docs/css =====

===== docs/css/alphabet.css =====
.alphabet-sticky {
  position: sticky;
  top: 1rem;
  display: flex;
  justify-content: center; /* center alphabet horizontally in the margin */
}

.alphabet-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 0.3em;
  font-size: 0.9rem;
}

.md-sidebar--secondary nav a {
  text-decoration: none;
  color: var(--md-typeset-color);
}

.md-sidebar--secondary nav a:hover {
  text-decoration: underline;
}

.md-sidebar--secondary nav a.active {
  font-weight: bold;
  color: var(--md-accent-fg-color);
}

.md-sidebar--secondary nav {
  padding-top: 0.5rem;
}

===== docs/css/cm-logo.css =====
@font-face {
  font-family: 'DancingScript';
  src: url('../fonts/DancingScript-Bold.ttf') format('truetype');
  font-weight: bold;
  font-style: normal;
}

.logo-text {
  font-family: 'DancingScript', cursive;
  font-weight: bold;
  font-size: 1.2em;
  vertical-align: middle;
  color: currentColor;
}

===== docs/css/color-vars.css =====
:root {
  --color-good: #228B22;
  --color-bad: #B22222;
  --color-warn: #8B4513;
}

[data-md-color-scheme="dark"] {
  --color-warn: #FFD700;
}


===== docs/css/diagram-zoom.css =====
/* Clickable SVGs before lightbox opens */
.mz-zoomable {
    cursor: zoom-in;
}

/* Lightbox overlay */
.mz-lightbox {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.65);
    z-index: 1000;
}

/* Show overlay */
.mz-lightbox[aria-hidden="false"] {
    display: flex;
    animation: mz-fade 0.18s ease-out;
}

/* Lightbox content container */
.mz-lightbox__content {
    max-width: 98vw;
    max-height: 98vh;
    overflow: visible;   /* allow zoom to expand beyond container */
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Zoomable SVG inside lightbox */
.mz-lightbox__svg {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    transition: transform 0.2s ease;
    transform-origin: center center;
    cursor: grab;        /* drag cursor inside overlay */
    touch-action: none;  /* pinch support */
    background: var(--md-default-bg-color, #fff);
    border-radius: 0.25rem;
    box-shadow: var(--md-shadow-z3, 0 10px 30px rgba(0, 0, 0, 0.35));
}

.mz-lightbox__svg:active {
    cursor: grabbing;
}

/* Fade animation */
@keyframes mz-fade {
    from { opacity: 0; }
    to { opacity: 1; }
}

@media (prefers-reduced-motion: reduce) {
    .mz-lightbox[aria-hidden="false"] {
        animation: none;
    }
}
