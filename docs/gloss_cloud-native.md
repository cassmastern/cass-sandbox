# Glossary of Cloud-Native Terms

Below is a list of terms foundational to cloud-native ecosystems.

| **Term/Acronym** | **Full Description** | **Extra Details** |
| ---------------- | -------------------- | ----------------- |
| **Chaos Engineering** | The practice of intentionally injecting failures into a system to test its resilience and identify weaknesses before they cause outages in production. | Tools: Chaos Monkey, Gremlin. Helps build confidence in system reliability under real-world conditions. |
| **CI/CD and Continuous Deployment** | When integrated, CI/CD together make it possible to implement Continuous Deployment. In Continuous Deployment, application changes run through the CI/CD pipeline and passing builds get deployed directly and seamlessly to fully automated production environments. Teams practicing Continuous Delivery can deploy to production on a daily or even hourly schedule. | Reduces manual intervention in releases; enables rapid iteration and delivery of features to users. |
| **Cloud** | A term for delivering hosted services over the internet. Cloud services differ from traditional infrastructure and platform hosting because they are elastic (users can employ only as much service as they need), sold on demand, and fully managed by the provider (requires only a computer and Internet access). See: Private Cloud, Public Cloud. | Examples: AWS, Azure, Google Cloud. Can be deployed as public, private, or hybrid models, often billed on a pay-as-you-go basis. |
| **CNCF** | The Cloud Native Computing Foundation (CNCF) is a Linux Foundation project that was founded in 2015 to help advance container technology and align the tech industry around its evolution. Today CNCF hosts critical components of the global technology infrastructure, and "*brings together the world’s top developers, end users, and vendors and runs the largest open source developer conferences.*" | Hosts major projects like Kubernetes, Prometheus, Envoy, and Fluentd. Provides certifications like CKA/CKAD. |
| **Configuration Management** | Specifically, the automation of server configuration and management, using tools such as Ansible, Puppet, Chef, or Terraform. | Enables consistent, repeatable environment setup; essential for Infrastructure as Code (IaC) practices. |
| **Containers** | Lightweight, standalone executable software packages that include everything required to run an application: code, runtime, system tools, libraries, and settings. Containers are a sort of ‘standard unit’ of software that packages the code with all its dependencies so it can run anywhere, in any computing environment. | Common runtimes: Docker, containerd. Often orchestrated using Kubernetes for scaling and reliability. |
| **Continuous Delivery** | Continuous Delivery (CD) starts where Continuous Integration ends. CD automates the delivery of CI’s small, iterative changes to run on cloud-based infrastructure. Most teams work with multiple environments outside the production pipeline, such as development and testing environments, and CD provides an automated way to push code changes to them. CD automation then performs any necessary service calls to web servers or databases, and executes procedures when applications are deployed. | Bridges CI with deployment workflows; ensures code is always in a deployable state. Often paired with automated testing. |
| **Continuous Integration** | Continuous Integration (CI) is a development approach where teams implement small changes and check in code to version-control repositories frequently, so that the codebase is constantly iterated and updated. The technical goal of CI is to establish a consistent and automated way to build, package, and test applications. | Tools include Jenkins, GitHub Actions, GitLab CI/CD, and CircleCI. CI reduces integration issues and speeds up feedback loops. |
| **Cross-Functional Teams** | On such a team, members have different skills, but work collaboratively toward the same goal. Team members have all competencies necessary for accomplishing the work within the team—so there are no dependencies on others outside the team. In software development this typically means frontend and backend developers, database and UX specialists, QA engineers, and any other role necessary for producing the product or service. | Encourages autonomy, reduces bottlenecks, and increases delivery speed; common in Agile and DevOps environments. |
| **Culture** | How individuals within an organisation communicate and work with each other. Culture is the sum of the daily actions that you take, your routines. If you talk to people as part of doing your work, you have a collaborative culture. Needing to seek permission before trying something new means you have a hierarchical culture. If you change the actions, you change the culture. | Shapes adoption of cloud-native practices; strong DevOps culture supports collaboration, automation, and continuous improvement. |
| **Data-Driven Design** | The practice of developing or improving a product based on things you can measure. Metrics like site analytics, carrying out A/B testing, or surveying users for feedback are all used to make design decisions. | Requires reliable analytics tools and KPIs; helps ensure decisions align with real user behavior and business goals. |
| **Design Thinking** | A human-centred approach to business processes. Design thinking focuses on customer problems and challenges as the foundation to producing products and services that satisfy their wants and needs, and is an excellent tool to combine with Cloud Native development processes. | Typically involves stages: Empathize, Define, Ideate, Prototype, Test. Encourages innovation and iteration. |
| **DevOps** | Both a culture and a set of processes aimed at reducing the division between software development and its actual operation. With DevOps, the traditionally siloed Development and Operations teams work together as one cohesive team (or, sometimes, two teams in tight collaboration). The approach facilitates fast and seamless software development while optimising both productivity and reliability. Companies adopting the DevOps model create teams that embrace the entire development and infrastructure lifecycle in their scope of responsibility. See: SRE. | Key practices: CI/CD, Infrastructure as Code, monitoring, incident response, and continuous feedback. |
| **GitOps** | A paradigm for managing infrastructure and application deployments using Git as the single source of truth. Changes to infrastructure or applications are made via Git commits, which trigger automated workflows to reconcile the actual state with the desired state. | Tools: ArgoCD, Flux. Enhances auditability, collaboration, and rollback capabilities. |
| **Greenfield Project** | Building a complete software development system where previously there was none. In Cloud Native, it means not just cloud-based infrastructure but also incorporates architecture, design, process, and culture—basically, starting completely from scratch in every possible area. Greenfield development is often viewed as advantageous because it is free from constraints that can be imposed by a system’s existing networks/infrastructure. | Opposite of “brownfield” projects, which involve upgrading or integrating with existing systems. |
| **Infrastructure as Code (IaC)** | The practice of managing and provisioning infrastructure through machine-readable definition files (e.g., YAML, JSON) rather than manual processes. IaC enables version control, reproducibility, and automation of infrastructure deployment. | Popular tools: Terraform, AWS CloudFormation, Pulumi. Reduces configuration drift and human error. |
| **Microservices** | An approach to application development in which a large application is built as a suite of modular components or services. Each service runs a unique process and usually manages its own database. A service can generate alerts, log data, support UIs and authentication, and perform various other tasks. Because microservices enable each component to be isolated, rebuilt, redeployed, and managed independently, development teams can take a more decentralized (nonhierarchical) approach to building software. | Promotes scalability and resilience; often paired with containerization and service mesh technologies. |
| **Monolith** | A software application in which different components combine into a single executable program, launched from a single platform. Monolithic applications can only be released once all components are ready, which can lead to long release cycles. | Easier to develop initially but harder to scale and maintain compared to microservices. |
| **Observability** | The ability to understand the internal state of a system by analyzing its outputs, such as logs, metrics, and traces. Observability goes beyond traditional monitoring by enabling deeper insights into system behavior and root-cause analysis. | Key tools: Prometheus (metrics), Grafana (visualization), Jaeger (tracing). Essential for debugging distributed systems. |
| **Orchestration** | Refers to the automated configuration, coordination, and management of computer systems and software. In cloud computing, it refers more specifically to orchestrator tools. The best known is Kubernetes, an open-source system for automating the deployment, scaling, and management of containerised applications. In Cloud Native, orchestration is all about managing the lifecycles of containers, especially in large, dynamic environments. (Dev)Ops teams use container orchestration to control and automate tasks such as the availability, provisioning, and deployment of containers, load balancing of containers across infrastructure, and scaling up/down by adding/removing containers as needed. See also: Containers. | Other orchestration tools: Apache Mesos, Docker Swarm, Nomad. Enables declarative management of infrastructure and services. |
| **Private Cloud** | A Private Cloud is meant to serve a single company. It’s usually built and operated by said company in its own data centre. A Private Cloud provides greater control over data storage and other operational and security aspects. | Offers customization and compliance benefits; examples: VMware vSphere, OpenStack. |
| **Public Cloud** | Public Cloud providers sell cloud services to any client, who creates an account with them. All clients share the same pool of computing resources. Examples of Public Cloud providers include Amazon Webservices (AWS), Microsoft Azure, and Google Cloud. | Offers scalability and low upfront cost; often includes free-tier or trial usage for onboarding. |
| **Serverless** | A cloud computing execution model where the cloud provider dynamically manages the allocation of machine resources. Developers focus on writing code (functions) that runs in stateless compute containers triggered by events (e.g., HTTP requests). Billing is based on actual usage rather than pre-purchased capacity. | Examples: AWS Lambda, Azure Functions, Google Cloud Functions. Ideal for event-driven, ephemeral workloads. |
| **Service Mesh** | A dedicated infrastructure layer for managing service-to-service communication in a microservices architecture. It provides features like load balancing, service discovery, encryption, and observability, typically implemented via sidecar proxies. | Popular tools: Istio, Linkerd, Consul. Enhances security and reliability without requiring changes to application code. |
| **Sidecar Pattern** | A design pattern where a secondary container (the "sidecar") is deployed alongside the primary application container to provide auxiliary functionality, such as logging, monitoring, or network proxying. | Commonly used in service meshes (e.g., Envoy proxy in Istio). Decouples cross-cutting concerns from the main application logic. |
| **SRE** | Site Reliability Engineering (SRE) is a term coined by Google to explain how it runs its systems. It was Google’s answer to today's challenges with ensuring application performance and reliability at unprecedented scale. In SRE, responsibility for an organisation’s platform is split between a product team, which focuses on delivery of the business value, application, or service (including innovation), and a reliability team, which focuses on both maintaining and improving the platform itself. | Practices include error budgets, service-level objectives (SLOs), and automated remediation. Bridges DevOps principles with operational excellence. |
| **Twelve-Factor App** | A methodology for building software-as-a-service (SaaS) applications that are portable, scalable, and resilient. The twelve factors include declarative formats for setup, stateless processes, and loose coupling between components. | Aligns well with microservices and cloud-native architectures; promotes DevOps-friendly practices. |
| **Unified Logging** | A centralized approach to collecting, storing, and analyzing logs from all components of a distributed system. Unified logging simplifies troubleshooting and provides a single source of truth for system behavior. | Tools: ELK Stack (Elasticsearch, Logstash, Kibana), Fluentd. Critical for debugging and compliance. |
| **Virtual Private Cloud (VPC)** | An isolated virtual network within a public cloud provider, where resources (e.g., VMs, databases) can be deployed with controlled access. A VPC mimics the security and control of a private cloud while leveraging public cloud scalability. | Key features: Subnets, firewalls, VPN connectivity. Used for multi-tier architectures and hybrid cloud setups. |
| **XaaS (Everything as a Service)** | A catch-all term for cloud services delivered on-demand, including IaaS, PaaS, SaaS, and newer models like FaaS (Function as a Service) or DBaaS (Database as a Service). | Reflects the shift from owning infrastructure to consuming services. Examples: AWS RDS (DBaaS), Twilio (CPaaS). |
| **YAML (Yet Another Markup Language)**| A human-readable data serialization format commonly used for configuration files in cloud-native tools (e.g., Kubernetes manifests, Ansible playbooks). Combines simplicity with support for complex structures. | Superseded JSON for many DevOps use cases due to readability and inline comments. |
| **Zero Trust** | A security model that assumes no implicit trust for any entity (users, devices, or services) inside or outside a network. Access is granted based on strict identity verification and least-privilege principles. | Key components: Multi-factor authentication (MFA), microsegmentation, and continuous monitoring. Critical for modern distributed systems. |

